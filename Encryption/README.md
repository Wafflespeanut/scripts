Zombipher (yeah, it's quite a mess!)
======

This is my encryption cipher, built completely for (my) learning purposes. Over the past few weeks, I've been learning new stuff in Python by finding different ways of getting into the cipher, and patching the algorithm so that it gets stronger every time.

It's quite straight-forward (easy to understand with my comments). And, it's built by a lot of helper functions, for improving readability.

CURRENT PURSUIT: Trying to fix the ciphertext output to 128-bits.

How it works?
======
- Using the prime numbers generated by the sieve (of Eratosthenes), the key is dissolved into the phrase to be encrypted.

- Firstly, the text and the key are turned to hexadecimal things using hexed(). Then, they're sorted using the primes. The hexed key is inserted into the nth prime number index, while the remaining chars in the phrase are shifted.

- Now, ASCII values are mixed into the numbers using add(). It takes the numbers from the combined array, adds it to the ASCII value of the chosen character from the key, and finally overwrites the original value with the last digit of the answer.

- Then, the iteration part. Iterating the encrypted text again and again makes it secure. But, longer iterations could lead to merciless outputs, which can kill your processor.

- During the last iteration, a random prime number chosen depending on the key. For a change, the iteration is carried out once using this random prime (this ensures varied ciphertexts during every run of the program)

- Once the iterations are complete, the characters in the ciphertext are shifted by the ASCII value of each character in the key, so that we get a "zombified" ciphertext.

- The shift() function can sometimes peek into foreign characters, which can't be interpreted by the program later, during decryption. To prevent that, the ciphertext is "hexed", which indeed fixes the problem.

- During decryption, the reverse processes are carried out by char(), extract(), sub(), find(), dit() functions.

- I've also added a few 'tries' to print custom messages for possible causes of the errors instead of the errors themselves.

The cipher caught me this way. If at least one iteration is allowed, the encrypted text has a lot of similar characters. A few dissimilarities here and there are what determine the output. As far as I can see, there are no bugs. But like I said, it isn't entirely intrusion-free. There could be a hole somewhere. Whenever I come across one, I'll try to patch it ASAP...